const acorn = require('acorn');
const console = require('./console');


// Match sub-tree pattern on the given AST (return on any one match)
// ast: JavaScript AST generated by `acorn.parse()`
// pattern: our custom subtree pattern to match with the AST
// callback: `function(captureId, astNode) { ... }` invoked when `$capture:` is set on pattern
const findOneOnAcornAst = (ast, pattern, callback) => {
  const matchSubTree = (astNode, ptnNode, callbackItems) => {
    if (!astNode || !(astNode instanceof acorn.Node)) return false;

    for (let key in ptnNode) {
      if (key.startsWith('$')) continue; // our magic attribute

      if (typeof ptnNode[key] === 'string') {
        if (!astNode[key] || astNode[key] != ptnNode[key]) return false;
      }
      else if (ptnNode[key] instanceof Array) {
        if (!(astNode[key] instanceof Array)) return false;
        const allFound = ptnNode[key].every(ptnSubNode =>
          (0 <= astNode[key].findIndex(astSubNode => {
            //FIXME: we only handle `{ ... }` object on `[ ... ]` for now
            return matchSubTree(astSubNode, ptnSubNode, callbackItems);
          }))
        );
        if (!allFound) return false;
      }
      else if (typeof ptnNode[key] === 'object') {
        const matched = matchSubTree(astNode[key], ptnNode[key], callbackItems);
        if (!matched) return false;
      }
    }

    const captureId = ptnNode.$capture;
    if (captureId) {
      callbackItems.push({captureId, astNode});
    }
    return true;
  };

  let callbackQueue = [];
  const traverse = (astNode) => {
    if (!astNode || !(astNode instanceof acorn.Node)) return false;

    let callbackItems = [];
    if (matchSubTree(astNode, pattern, callbackItems)) {
      callbackQueue.push(callbackItems);
      return true;
    }

    // walk to possible children recursively
    for (let key in astNode) {
      if (astNode[key] instanceof Array) {
        const childNodes = astNode[key];
        const found = childNodes
          .filter(childNode => childNode instanceof acorn.Node)
          .some(childNode => traverse(childNode))
        if (found) return true;
      }
      else if (astNode[key] instanceof acorn.Node) {
        const childNode = astNode[key];
        if (traverse(childNode)) return true;
      }
    }
    return false;
  };

  const found = traverse(ast);
  if (found && (typeof callback === 'function')) {
    callbackQueue.forEach(cbItems => {
      cbItems.forEach(cbItem => callback(cbItem.captureId, cbItem.astNode));
    });
  }
  return found;
};


// -----------------------------------------------------------------------------


function injectCallback(script) {
  const ast = acorn.parse(script);

  // looking for `manifest.textTracks.forEach(function(...){...})`
  const pattern = {
    $capture: 'root',
    type: 'CallExpression',
    callee: {
      type: 'MemberExpression',
      object: {
        type: 'MemberExpression',
        object: {
          $capture: 'manifest',
          type: 'Identifier',
        },
        property: {
          type: 'Identifier',
          name: 'textTracks',
        },
      },
      property: {
        type: 'Identifier',
        name: 'forEach',
      },
    },
  };

  let injectionOffset, manifestIdName;
  const found = findOneOnAcornAst(ast, pattern, (captureId, astNode) => {
    if (captureId === 'root') {
      injectionOffset = astNode.start;
    }
    else if (captureId === 'manifest') {
      manifestIdName = astNode.name;
    }
  });

  if (found && (injectionOffset !== undefined)) {
    const payload = `(window.__NflxMultiSubs&&window.__NflxMultiSubs.updateManifest(a));`;
    return script.substr(0, injectionOffset) + payload + script.substr(injectionOffset);
  }
  return null;
}


// -----------------------------------------------------------------------------


// add 1080p for Chrome (ref. https://github.com/truedread/netflix-1080p)
function injectHiResHackChrome(script) {
  const ast = acorn.parse(script);

  // looking for `uaTestResult = /CrOS/.test(a.userAgent);` and `uaTestResult && this.oo.push(x.V.TH);` in a same function
  const pattern = {
    $capture: 'root',
    type: 'FunctionDeclaration',
    body: {
      type: 'BlockStatement',
      body: [
        // expression: `uaTestResult = /CrOS/.test(a.userAgent);`
        {
          type: 'ExpressionStatement',
          expression: {
            type: 'AssignmentExpression',
            operator: '=',
            left: {
              $capture: 'uaTestResult',
              type: 'Identifier',
            },
            right: {
              type: 'CallExpression',
              callee: {
                type: 'MemberExpression',
                object: {
                  type: 'Literal',
                  raw: '/CrOS/',
                },
              },
              arguments: [
                {
                  type: 'MemberExpression',
                  property: {
                    type: 'Identifier',
                    name: 'userAgent',
                  }
                },
              ],
            },
          },
        },

        // expression: `uaTestResult2 && this.oo.push(x.V.TH);`
        {
          type: 'ExpressionStatement',
          expression: {
            type: 'LogicalExpression',
            left: {
              $capture: 'uaTestResult2',
              type: 'Identifier',
            },
            operator: '&&',
            right: {
              $capture: 'addHiResProfile',
              type: 'CallExpression',
              callee: {
                type: 'MemberExpression',
                property: {
                  type: 'Identifier',
                  name: 'push',
                },
              },
            },
          },
        },
      ],
    },
  };

  let uaTestResult, uaTestResult2, injectionOffset, addHiResProfileExp;
  const found = findOneOnAcornAst(ast, pattern, (captureId, astNode) => {
    if (captureId === 'uaTestResult')
      uaTestResult = astNode.name;
    else if (captureId === 'uaTestResult2')
      uaTestResult2 = astNode.name;
    else if (captureId === 'addHiResProfile') {
      const expLength = (astNode.end - astNode.start);
      injectionOffset = astNode.end;
      addHiResProfileExp = script.substr(astNode.start, expLength);
    }
  });

  if ((found) && (uaTestResult !== undefined) &&
      (injectionOffset !== undefined) &&
      (addHiResProfileExp !== undefined) &&
      (uaTestResult === uaTestResult2))
  {
    const payload = `((!${uaTestResult})&&${addHiResProfileExp});`;
    if (script[injectionOffset] === ';') {
      injectionOffset = (injectionOffset + 1);
    }
    return script.substr(0, injectionOffset) + payload + script.substr(injectionOffset);
  }
  return null;
}


// -----------------------------------------------------------------------------


// add 1080p for Firefox
function injectHiResHackFirefox(script) {
  const ast = acorn.parse(script);

  // looking for profiles enumeration in a same function, for example:
  // ...
  // f.sI = "playready-h264mpl30-dash";
  // f.dB = "playready-h264mpl31-dash";
  // f.PV = "playready-h264mpl40-dash";
  // ...
  const ptn1 = {
    type: 'BlockStatement',
    body: ['playready-h264mpl30-dash',
           'playready-h264mpl31-dash',
           'playready-h264mpl40-dash'].map((p, i) => {
      return {
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          operator: '=',
          left: {
            type: 'MemberExpression',
            property: {
              $capture: `profile-${i}`,
              type: 'Identifier',
            },
          },
          right: {
            type: 'Literal',
            value: p,
          },
        },
      };
    }),
  };

  let prof0, prof1, prof2;
  let found = findOneOnAcornAst(ast, ptn1, (captureId, astNode) => {
    if (captureId === 'profile-0') prof0 = astNode.name;
    else if (captureId === 'profile-1') prof1 = astNode.name;
    else if (captureId === 'profile-2') prof2 = astNode.name;
  });
  if (!found || !prof0 || !prof1 || !prof2) return null;

  // looking for profile set up, for example:
  // ...
  // this.sr = [D.V.sI, D.V.dB];
  // ...
  const ptn2 = {
    type: 'AssignmentExpression',
    left: {
      type: 'MemberExpression',
      object: {
        type: 'ThisExpression',
      },
    },
    right: {
      $capture: 'profiles-list',
      type: 'ArrayExpression',
      elements: [
        {
          type: 'MemberExpression',
          property: {
            type: 'Identifier',
            name: prof0,
          }
        },
        {
          $capture: 'profile-stmt',
          type: 'MemberExpression',
          property: {
            type: 'Identifier',
            name: prof1,
          }
        },
      ],
    },
  };

  let listEnd, profileStmt;
  found = findOneOnAcornAst(ast, ptn2, (captureId, astNode) => {
    if (captureId === 'profiles-list') {
      listEnd = (astNode.end - 1);
    }
    else if (captureId === 'profile-stmt') {
      profileStmt = script.substr(astNode.start, (astNode.end - astNode.start));
    }
  });
  if (!found || !listEnd || !profileStmt) return null;

  return script.substr(0, listEnd) + ',' + profileStmt.replace(prof1, prof2) + script.substr(listEnd);
}


// -----------------------------------------------------------------------------


module.exports = {
  patch: (script) => {
    let patched = injectCallback(script);
    if (patched) {
      script = patched;
      console.log('Patched: callback');
    }
    else {
      console.error('Error: cannot inject callback');
    }


    if (BROWSER === 'chrome') {
      patched = injectHiResHackChrome(script);
    }
    else if (BROWSER === 'firefox') {
      patched = injectHiResHackFirefox(script);
    }

    if (patched) {
      script = patched;
      console.log('Patched: hi-res hack');
    }
    else {
      console.error('Error: cannot inject hi-res hack');
    }
    return script;
  }
};
